
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Use case: Quantum chemistry &#8212; NordIQuEst Application Library</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_lesson.css?v=0c089442" />
    <link rel="stylesheet" type="text/css" href="../../../_static/term_role_formatting.css?v=4194e21c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=a5c4661c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/minipres.js?v=a0d29692"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>window.MathJax = {"tex": {"macros": {"vr": "\\vec{r}", "ket": ["\\left| #1 \\right\\rangle", 1], "bra": ["\\left| #1 \\right\\langle", 1], "iprod": ["\\left\\langle #1 | #2 \\right\\rangle", 2]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'training-material/qas2022/notebooks/E2_VQE-H2';</script>
    <link rel="icon" href="../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Quantum software testing with Quito" href="quito.html" />
    <link rel="prev" title="Use case: Optimization" href="E2_optimization.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/nq_logo2.png" class="logo__image only-light" alt="NordIQuEst Application Library - Home"/>
    <script>document.write(`<img src="../../../_static/nq_logo2.png" class="logo__image only-dark" alt="NordIQuEst Application Library - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Application Library</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../README.html"><strong>NordIQuEst Application Library</strong></a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../hybrid-algorithms/index.html"><strong>Hybrid Algorithms</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/QAOA/index.html">Quantum Approximate Optimization Algorithm (QAOA)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/QAOA/MaxCut.html">Comparison of Different Optimizers for QAOA on a Max Cut instance</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Chemistry/index.html">Quantum Chemistry</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Chemistry/Installation.html">Installation instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Chemistry/Theory.html">Theory: Quantum Chemistry on Quantum Computers</a></li>

<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Chemistry/VQE.html">Notebook example: VQE</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Walk/index.html">Quantum Walk</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Walk/ClassicalRandomWalk.html">Classical Random Walk on a Quantum Computer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Walk/QuantumRandomWalk.html">Quantum Random Walk on a Quantum Computer</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/VQE/index.html">Variational Quantum Eigensolver (VQE) Tutorial</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/VQE/vqe-h2-cirq.html">Cirq: Variational Quantum Eigensolver for <span class="math notranslate nohighlight">\(H_2\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/VQE/vqe-h2-qiskit.html">Qiskit: Variational Quantum Eigensolver for <span class="math notranslate nohighlight">\(H_2\)</span></a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/QuantumReservoirComputing/index.html">Quantum Reservoir Computing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/QuantumReservoirComputing/Logistic%20map.html">Quantum Reservoir Computing: Logistic map</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../real-devices/index.html"><strong>Real Devices</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../real-devices/ex3-qal9000-demo/index.html">ex3-qal9000 Demo</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../real-devices/ex3-qal9000-demo/compute-bloch-frames.html">ex3-qal9000 Demo: StateTomography on QAL9000</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="../../../real-devices/intro-to-helmi-qiskit.html">Introduction to Helmi with Qiskit</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../simulators/index.html"><strong>Simulators</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../simulators/ex3/index.html">ex3 Simulators</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/ex3/qiskit/README.html">Running Quantum programs on the Qiskit Simulator in eX3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/ex3/qsim/README.html">QSIM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/ex3/QuEST/README.html">Guide of Running QuEST in eX3</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../simulators/lumi/index.html">LUMI Simulators</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../simulators/lumi/qiskit/index.html">Qiskit</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../simulators/lumi/qiskit/v0.12.0/README.html">v0.12.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../simulators/lumi/qiskit/v1.1.1/README.html">v1.1.1</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/lumi/qsim/README.html">QSim</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/lumi/QuEST/README.html">QuEST</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../../index.html"><strong>Training Material Archive</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 current active has-children"><a class="reference internal" href="../index.html">Quantum Autumn School 2022</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l3 current active has-children"><a class="reference internal" href="index.html">Notebooks</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="E1_qc-1.html"><strong>Quantum programming I</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="E1_qc-2.html"><strong>Quantum programming II</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="E1_qc-3.html"><strong>Quantum programming III</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="E2_optimization.html"><strong>Use case: Optimization</strong></a></li>
<li class="toctree-l4 current active"><a class="current reference internal" href="#"><strong>Use case: Quantum chemistry</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="quito.html">Quantum software testing with Quito</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../slides/index.html">Slides</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../slides/landscape.html">The HPC-QC landscape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qc_hardware.html">Overview of different QC hardware approaches and QC types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/programming_qc.html">Introduction to high-level languages for QC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/hybrid_hpc_qc.html">The hybrid HPC-QC approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/software_stack_overview.html">Overview of the software stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/hybrid_algorithms.html">Hybrid classical/quantum algorithms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qc_testing.html">Quantum software testing</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../qas2023/index.html">Quantum Autumn School 2023</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../qas2023/notebooks/index.html">Notebooks</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/E2_VQE-H2.html">Tutorial - Quantum chemistry</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/intro-to-helmi-qiskit.html">Tutorial - Introduction to Helmi with qiskit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/Notebook_maxcut_Qas2023.html">Tutorial - Quantum Alternating Operator Ansatz</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/Notebook_maxcut_Qas2023_sol.html">Solutions - Tutorial - Quantum Alternating Operator Ansatz</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/Qubit_Spectroscopy_Analysis.html">Tutorial - Qubit Spectroscopy Analysis</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../qas2023/slides/index.html">Slides</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/slides/hpc-qc.html">HPC-QC integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/slides/software-stack.html">QC software stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/slides/hybrid-classical-quantum.html">Hybrid Classical/Quantum Algorithms</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Information</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../docs/authors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/acknowledgement.html">Acknowledgement</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/NordIQuEst/application-library" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/training-material/qas2022/notebooks/E2_VQE-H2.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Use case: Quantum chemistry</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-session-implement-vqe-for-h-2"><strong>Practice session: implement VQE for <span class="math notranslate nohighlight">\(H_2\)</span></strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis"><strong>Synopsis</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation"><strong>Implementation</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#measure-expectation-values"><strong>Measure Expectation values</strong></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scan-the-parameter-interval"><strong>Scan the parameter interval</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapping-outcome-states-to-values"><strong>Mapping outcome states to values</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#further-problems"><strong>Further problems</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary"><strong>Summary</strong></a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="use-case-quantum-chemistry">
<h1><strong>Use case: Quantum chemistry</strong><a class="headerlink" href="#use-case-quantum-chemistry" title="Link to this heading">#</a></h1>
<section id="practice-session-implement-vqe-for-h-2">
<h2><strong>Practice session: implement VQE for <span class="math notranslate nohighlight">\(H_2\)</span></strong><a class="headerlink" href="#practice-session-implement-vqe-for-h-2" title="Link to this heading">#</a></h2>
<p>In the lecture we gave an example of the variational quantum eigensolver (VQE) algorithm: computing the ground energy of molecular hydrogen, <span class="math notranslate nohighlight">\(H_2\)</span>. This is one of the smallest systems one can imagine to start experimenting with VQE. It has also been implemented on an actual quantum computer as reported in <a class="reference external" href="https://arxiv.org/abs/1512.06860">O’Malley etal 2015, <em>Scalable Quantum Simulation of Molecular Energies</em>, arXiv:1512.06860v2</a>. The following figure given in the article summarizes the entire setup:</p>
<p><img alt="Fig. 1. The variational quantum eigensolver circuit and hardware. Source: arXiv:1512.06860v2" src="../../../_images/omalley-etal-2016-vqe.png" /></p>
<p>Fig. 1. The variational quantum eigensolver circuit and hardware. Source: <a href="https://arxiv.org/abs/1512.06860">arXiv:1512.06860v2</a>.</p>
<p>In this session, we are going to implement the VQE algorithm for <span class="math notranslate nohighlight">\(H_2\)</span> from scratch using the circuit in Fig. 1 and the data given in the paper.</p>
<section id="synopsis">
<h3><strong>Synopsis</strong><a class="headerlink" href="#synopsis" title="Link to this heading">#</a></h3>
<p>Before we begin, let us summarize the task ahead of us, and what exactly we are going to do. Remember that VQE starts with classical preparations. This involves all the classical computational chemistry computations we summarized in the lecture. As a result of these preparations we have the qubit Hamiltonian and the ansatz circuit that represents the parameterized unitary. We assume that all this work has been completed: the result is the ansatz circuit and the Hamiltonian shown in the figure above.</p>
<p>Let us summarize the computation shown in the figure.</p>
<p>The algorithm consists of two parts. Firstly, there is a computation carried out on a quantum computer. This is divided into three parts in the figure, (1) Prepare initial state, (2) Apply Parameterized Ansatz, (3) Measure Expectation values. The entire quantum computation is performed using the circuit shown at the bottom part, ‘Software’. Note the circuit contains only two qubits.</p>
<p>Secondly, there is the classical part, comprising (1) Calculate Energy and (2) Classical Optimizer Suggests New Parameters <span class="math notranslate nohighlight">\(\theta\)</span>. The qubit Hamiltonian of <span class="math notranslate nohighlight">\(H_2\)</span> is also shown on the right.</p>
<p>Note that the top part of the figure also shows a rough outline of physical pulses with timings that are needed to run the circuit.</p>
<p>We will implement both the classical and quantum parts in Python using Qiskit. We will implement the algorithm from scratch <em>without</em> using the more advanced Qiskit libraries. We will only rely circuits and measurements. In principle, we will show how to implement the algorithm in <em>any language that contains circuits and measurements</em>.</p>
<p>The rationale of showing this simple, low level implementation is to give a taste of what is going on behind the scenes of the more advanced (Qiskit) libraries.</p>
</section>
<section id="implementation">
<h3><strong>Implementation</strong><a class="headerlink" href="#implementation" title="Link to this heading">#</a></h3>
<p>Let us start by creating a routine for the circuit in the figure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">assemble</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Parameter</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Routines</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>
<span class="k">def</span> <span class="nf">create_ansatz_circuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create H2 ansatz circuit given in O&#39;Malley etal 2015.</span>

<span class="sd">    args</span>
<span class="sd">        qreg           - qubits</span>
<span class="sd">        creg           - classical bits</span>
<span class="sd">        parameter      - parameter for parameterized circuit</span>

<span class="sd">    returns</span>
<span class="sd">        ansatz_circuit - a parameterized circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

    <span class="c1"># H2 circuit</span>
    <span class="c1"># 1 - create HF reference state</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="c1"># 2 - ansatz: U(theta)</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># 3</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 4 - parameterized Z-rotation</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 5</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 6</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ansatz_circuit</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Main program</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>

<span class="c1"># variables</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;θ&quot;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">create_ansatz_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

<span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/887f69315504cf952390b115e0fe7d35528fad4c4364cb709be07194587c2d6c.png" src="../../../_images/887f69315504cf952390b115e0fe7d35528fad4c4364cb709be07194587c2d6c.png" />
</div>
</div>
<p>We have added barriers for better visualization.</p>
<p>The new feature here is a <em>parameter</em> that is inserted in the <code class="docutils literal notranslate"><span class="pre">rz()</span></code> rotation in L40. It means every time when we update the parameter, we do not need to create a new circuit from scratch. This saves a lot of time in general. VQE circuits can be quite large. Imagine a circuit containing <span class="math notranslate nohighlight">\(10\)</span>k gates and <span class="math notranslate nohighlight">\(300\)</span> parameters. Creating fixed circuits each time one parameter needs to be updated will take much longer than updating a single value in the circuit. For this reason, when implementing VQE, it’s always best to use <em>parameterized circuits</em> if they are available in the programming language.</p>
<p>At this point we have accomplished the first two quantum components, (1) Prepare initial state, (2) Apply Parameterized Ansatz.</p>
<section id="measure-expectation-values">
<h4><strong>Measure Expectation values</strong><a class="headerlink" href="#measure-expectation-values" title="Link to this heading">#</a></h4>
<p>Next, let us focus on (3) Measure Expectation values. The qubit Hamiltonian we need to measure is as follows</p>
<div class="math notranslate nohighlight">
\[ 
H = g_0 \mathbb{1} + g_1 Z_0 + g_2 Z_1 + g_3 Z_0 Z_1 + g_4 Y_0 Y_1 + g_5 X_0 X_1
\]</div>
<p>where <span class="math notranslate nohighlight">\(g_i\)</span> are (real valued) coefficients that have been computed classically. They are given in the Table 1 in the appendix of O’Malley etal 2015. The values of <span class="math notranslate nohighlight">\(g_i\)</span> are functions of hydrogen-hydrogen bond length <span class="math notranslate nohighlight">\(R\)</span>. We will take the coefficients at bond length <span class="math notranslate nohighlight">\(R = 0.75\)</span> (in units <span class="math notranslate nohighlight">\(10^{-10}\)</span> m) where the energy is lowest (the actual bond length where the energy is lowest is <span class="math notranslate nohighlight">\(0.74\)</span>, which is close).</p>
<p>There is a problem though. We can perform measurements in the <span class="math notranslate nohighlight">\(Z\)</span> basis using the Qiskit <code class="docutils literal notranslate"><span class="pre">measure()</span></code> routine. However, we cannot directly measure the Pauli <span class="math notranslate nohighlight">\(X\)</span> or <span class="math notranslate nohighlight">\(Y\)</span> operators of the terms <span class="math notranslate nohighlight">\(X_0 X_1\)</span> and <span class="math notranslate nohighlight">\(Y_0 Y_1\)</span>. In order to measure the latter, we have to use the following trick:</p>
<ul class="simple">
<li><p>to measure <span class="math notranslate nohighlight">\(X\)</span>, perform basis transformation from the <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span></p></li>
<li><p>then measure the qubits as usual (in the <span class="math notranslate nohighlight">\(Z\)</span> basis) with <code class="docutils literal notranslate"><span class="pre">measure()</span></code>.</p></li>
</ul>
<p>The same applies to <span class="math notranslate nohighlight">\(Y\)</span> measurements, in this case we need to perform basis transformation from <span class="math notranslate nohighlight">\(Y\)</span> to <span class="math notranslate nohighlight">\(Z\)</span>.</p>
<p>In order to compute the average value <span class="math notranslate nohighlight">\(\langle H \rangle\)</span> of the (total) Hamiltonian we will use the fact that the total average is equal to the sum of averages of its terms,</p>
<div class="math notranslate nohighlight">
\[
\langle H\rangle = g_0 \langle \mathbb{1}\rangle + g_1 \langle Z_0\rangle + g_2 \langle Z_1\rangle + g_3 \langle Z_0 Z_1\rangle + g_4 \langle Y_0 Y_1\rangle + g_5 \langle X_0 X_1\rangle.
\]</div>
<p>So we need to compute the expectation value of each term, then multiply each with the respective coefficient <span class="math notranslate nohighlight">\(g_i\)</span>, and finally add averages of all terms. Note that <span class="math notranslate nohighlight">\(\langle\mathbb{1}\rangle = 1\)</span>, so we can just add the coefficient <span class="math notranslate nohighlight">\(g_0\)</span>.</p>
<p>Pseudo code wise, it means:</p>
<ul class="simple">
<li><p>Compute avg of H:</p>
<ul>
<li><p>Loop over terms, compute avg of each term</p></li>
</ul>
</li>
</ul>
<p>Now computing the average of a term like <span class="math notranslate nohighlight">\(X_0 X_1\)</span> means that we need to add the respective measurement mini-circuit at the end of the ansatz. This is how the part ‘(3) Measure Expectation values’ is realized in the circuit above in the figure, see the final light grey box.</p>
<p>In terms of implementation, it means that <em>instead of looping over terms we can loop over measurement mini-circuits</em>. And in order to be more efficient, let us create these mini-circuits prior to running the algorithm.</p>
<p>So let us add a routine that takes in a term (e.g. <span class="math notranslate nohighlight">\(X_0 X_1\)</span>) and creates the corresponding mini-circuit, which we can add at the end of the main ansatz circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">assemble</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Parameter</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Routines</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>
<span class="k">def</span> <span class="nf">create_ansatz_circuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create H2 ansatz circuit given in O&#39;Malley etal 2015.</span>

<span class="sd">    args</span>
<span class="sd">        qreg           - qubits</span>
<span class="sd">        creg           - classical bits</span>
<span class="sd">        parameter      - parameter for parameterized circuit</span>

<span class="sd">    returns</span>
<span class="sd">        ansatz_circuit - a parameterized circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

    <span class="c1"># H2 circuit</span>
    <span class="c1"># 1 - create HF reference state</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="c1"># 2 - ansatz: U(theta)</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># 3</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 4 - parameterized Z-rotation</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 5</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 6</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ansatz_circuit</span>


<span class="k">def</span> <span class="nf">paulis_to_measure_circ</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">hamlist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate measure circuits from hamiltonian pauli list</span>
<span class="sd">    for measurements in different bases.</span>

<span class="sd">    args</span>
<span class="sd">        qreg     - qubits</span>
<span class="sd">        creg     - classical bits</span>
<span class="sd">        hamlist  - total hamiltonian, i.e. pauli strings</span>

<span class="sd">    returns</span>
<span class="sd">        circuits - list of circuits that can be used to average over</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">hamlist</span><span class="p">:</span>
        <span class="n">minicirc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qubitno</span><span class="p">,</span> <span class="n">qubitop</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">sdg</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Error: INVALID qubit operation&quot;</span>

        <span class="n">minicirc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>
        <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minicirc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuits</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Main program</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>

<span class="c1"># variables</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;θ&quot;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">)),</span>
<span class="p">)</span>

<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">create_ansatz_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
<span class="n">ham_mini_circuits</span> <span class="o">=</span> <span class="n">paulis_to_measure_circ</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">)</span>

<span class="c1"># print result</span>
<span class="p">[</span><span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span> <span class="k">for</span> <span class="n">circ</span> <span class="ow">in</span> <span class="n">ham_mini_circuits</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      ┌─┐   
q1_0: ┤M├───
      └╥┘┌─┐
q1_1: ─╫─┤M├
       ║ └╥┘
c1: 2/═╩══╩═
       0  1 
      ┌─┐   
q1_0: ┤M├───
      └╥┘┌─┐
q1_1: ─╫─┤M├
       ║ └╥┘
c1: 2/═╩══╩═
       0  1 
      ┌─┐   
q1_0: ┤M├───
      └╥┘┌─┐
q1_1: ─╫─┤M├
       ║ └╥┘
c1: 2/═╩══╩═
       0  1 
      ┌───┐┌─┐   
q1_0: ┤ H ├┤M├───
      ├───┤└╥┘┌─┐
q1_1: ┤ H ├─╫─┤M├
      └───┘ ║ └╥┘
c1: 2/══════╩══╩═
            0  1 
      ┌─────┐┌───┐┌─┐   
q1_0: ┤ Sdg ├┤ H ├┤M├───
      ├─────┤├───┤└╥┘┌─┐
q1_1: ┤ Sdg ├┤ H ├─╫─┤M├
      └─────┘└───┘ ║ └╥┘
c1: 2/═════════════╩══╩═
                   0  1 
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[None, None, None, None, None]
</pre></div>
</div>
</div>
</div>
<p>The new routine <code class="docutils literal notranslate"><span class="pre">paulis_to_measure_circ()</span></code> takes in the total qubit Hamiltonian and outputs circuits which correspond to the terms of the Hamiltonian. We also needed to represent the Hamiltonian, to this end we use a tuple of tuples in L96. The smallest element has the form <code class="docutils literal notranslate"><span class="pre">(qubit_number,</span> <span class="pre">Pauli_matrix)</span></code>, where <code class="docutils literal notranslate"><span class="pre">qubit_number</span></code> is the index of the qubit for the Pauli observable.</p>
<p>Let’s summarize the computation of the average of the Hamiltonian. We need to compute the averages of terms. We do this by looping over terms, which are represented as mini-circuits. For each mini-circuit, we will take the ansatz, add to it the mini-circuit, and run the resulting circuit, collect measurement statistics and compute the average.</p>
</section>
</section>
<section id="scan-the-parameter-interval">
<h3><strong>Scan the parameter interval</strong><a class="headerlink" href="#scan-the-parameter-interval" title="Link to this heading">#</a></h3>
<p>We will not bother with classical optimization in this small implementation. The circuit has only one parameter—the angle <span class="math notranslate nohighlight">\(\theta\)</span> of the <span class="math notranslate nohighlight">\(R_z\)</span> rotation—which ranges between <span class="math notranslate nohighlight">\([-\pi, \pi]\)</span>. Instead of searching for the minimum value of <span class="math notranslate nohighlight">\(\langle H\rangle\)</span>, we will scan this interval and record the minimum energy.</p>
<p>Let us add a loop to do this.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">assemble</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Parameter</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Routines</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>
<span class="k">def</span> <span class="nf">create_ansatz_circuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create H2 ansatz circuit given in O&#39;Malley etal 2015.</span>

<span class="sd">    args</span>
<span class="sd">        qreg           - qubits</span>
<span class="sd">        creg           - classical bits</span>
<span class="sd">        parameter      - parameter for parameterized circuit</span>

<span class="sd">    returns</span>
<span class="sd">        ansatz_circuit - a parameterized circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

    <span class="c1"># H2 circuit</span>
    <span class="c1"># 1 - create HF reference state</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="c1"># 2 - ansatz: U(theta)</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># 3</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 4 - parameterized Z-rotation</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 5</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 6</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ansatz_circuit</span>


<span class="k">def</span> <span class="nf">paulis_to_measure_circ</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">hamlist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate measure circuits from hamiltonian pauli list</span>
<span class="sd">    for measurements in different bases.</span>

<span class="sd">    args</span>
<span class="sd">        qreg     - qubits</span>
<span class="sd">        creg     - classical bits</span>
<span class="sd">        hamlist  - total hamiltonian, i.e. pauli strings</span>

<span class="sd">    returns</span>
<span class="sd">        circuits - list of circuits that can be used to average over</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">hamlist</span><span class="p">:</span>
        <span class="n">minicirc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qubitno</span><span class="p">,</span> <span class="n">qubitop</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">sdg</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Error: INVALID qubit operation&quot;</span>

        <span class="n">minicirc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>
        <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minicirc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuits</span>


<span class="k">def</span> <span class="nf">get_ham_avg</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">ham_mini_circuits</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute average of the total qubit Hamiltonian.</span>

<span class="sd">    args</span>
<span class="sd">        params           - parameter value for the ansatz circuit</span>
<span class="sd">        ansatz           - ansatz circuit</span>
<span class="sd">        ham_mini_ciruits - pre-built circuits to measure Hamiltonian terms</span>
<span class="sd">        obs              - data for observables</span>
<span class="sd">        shots            - number of shots</span>

<span class="sd">    returns</span>
<span class="sd">        avg   - average of Hamiltonian</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># TODO</span>

    <span class="k">return</span> <span class="n">avg</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Main program</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>

<span class="c1"># variables</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;θ&quot;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">)),</span>
<span class="p">)</span>
<span class="n">shots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">no_of_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">param_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">no_of_points</span><span class="p">)</span>
<span class="c1"># g_i coeffs for R = 0.75</span>
<span class="n">g_coeff</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3435</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4347</span><span class="p">,</span> <span class="mf">0.5716</span><span class="p">,</span> <span class="mf">0.091</span><span class="p">,</span> <span class="mf">0.091</span><span class="p">]</span>
<span class="n">g_coeff_id</span> <span class="o">=</span> <span class="mf">0.2252</span>
<span class="c1"># graph</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">#</span>
<span class="n">obs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># start</span>
<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">create_ansatz_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
<span class="n">ham_mini_circuits</span> <span class="o">=</span> <span class="n">paulis_to_measure_circ</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">)</span>

<span class="c1"># record min val of hamiltonian</span>
<span class="n">h_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span>

<span class="c1"># scan theta domain [-pi, pi]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">param_range</span><span class="p">:</span>
    <span class="n">h_avg</span> <span class="o">=</span> <span class="n">get_ham_avg</span><span class="p">(</span>
        <span class="p">{</span><span class="n">theta</span><span class="p">:</span> <span class="n">x</span><span class="p">},</span> <span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">g_coeff</span><span class="p">,</span> <span class="n">ham_mini_circuits</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">shots</span>
    <span class="p">)</span>
    <span class="n">h_avg</span> <span class="o">+=</span> <span class="n">g_coeff_id</span>  <span class="c1"># add coeff of id term</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_avg</span><span class="p">)</span>  <span class="c1"># collect data for plotting</span>
    <span class="k">if</span> <span class="n">h_avg</span> <span class="o">&lt;</span> <span class="n">h_min</span><span class="p">:</span>  <span class="c1"># record min value</span>
        <span class="n">h_min</span> <span class="o">=</span> <span class="n">h_avg</span>

<span class="c1"># result</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">H_min =&quot;</span><span class="p">,</span> <span class="n">h_min</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>H_min = 0.2252
</pre></div>
</div>
</div>
</div>
<p>The loop in lines L141-147 walks through the interval <span class="math notranslate nohighlight">\([-\pi, \pi]\)</span> and finds the minimum energy. Of course, the answer is wrong—the value <span class="math notranslate nohighlight">\(0.2252\)</span> is just the value of the constant term—since we have not implemented the actual computation of the average.</p>
</section>
<section id="mapping-outcome-states-to-values">
<h3><strong>Mapping outcome states to values</strong><a class="headerlink" href="#mapping-outcome-states-to-values" title="Link to this heading">#</a></h3>
<p>To actually compute the average of a Hamiltonian term, we need to know how the outcomes of the measurement <span class="math notranslate nohighlight">\(00, 01, 10, 11\)</span> that Qiskit uses correspond to the actual real valued outcomes <span class="math notranslate nohighlight">\(+1, -1\)</span> for a particular observable like <span class="math notranslate nohighlight">\(Z_0\)</span> or <span class="math notranslate nohighlight">\(Z_0 Z_1\)</span> we measure. Without discussing this at length here, we are going to introduce dictionaries that record the mapping for each observable. Of course, there are other ways to implement this.</p>
<p>Let us fill in the generic routine for computing the average.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">assemble</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Parameter</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Routines</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>
<span class="k">def</span> <span class="nf">create_ansatz_circuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create H2 ansatz circuit given in O&#39;Malley etal 2015.</span>

<span class="sd">    args</span>
<span class="sd">        qreg           - qubits</span>
<span class="sd">        creg           - classical bits</span>
<span class="sd">        parameter      - parameter for parameterized circuit</span>

<span class="sd">    returns</span>
<span class="sd">        ansatz_circuit - a parameterized circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

    <span class="c1"># H2 circuit</span>
    <span class="c1"># 1 - create HF reference state</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="c1"># 2 - ansatz: U(theta)</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># 3</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 4 - parameterized Z-rotation</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 5</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 6</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ansatz_circuit</span>


<span class="k">def</span> <span class="nf">paulis_to_measure_circ</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">hamlist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate measure circuits from hamiltonian pauli list</span>
<span class="sd">    for measurements in different bases.</span>

<span class="sd">    args</span>
<span class="sd">        qreg     - qubits</span>
<span class="sd">        creg     - classical bits</span>
<span class="sd">        hamlist  - total hamiltonian, i.e. pauli strings</span>

<span class="sd">    returns</span>
<span class="sd">        circuits - list of circuits that can be used to average over</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">hamlist</span><span class="p">:</span>
        <span class="n">minicirc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qubitno</span><span class="p">,</span> <span class="n">qubitop</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">sdg</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Error: INVALID qubit operation&quot;</span>

        <span class="n">minicirc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>
        <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minicirc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuits</span>


<span class="k">def</span> <span class="nf">get_paulistr_avg</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate average of a Pauli string (e.g. XXY).</span>

<span class="sd">    args</span>
<span class="sd">        counts      - result of simulation: {&#39;00&#39;: 45, &#39;01&#39;: 34, . . .}</span>
<span class="sd">        obs         - data for calculating probabilities</span>
<span class="sd">        shots       - number of repetitions</span>

<span class="sd">    returns</span>
<span class="sd">        avg         - the average value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># TODO</span>

    <span class="k">return</span> <span class="n">avg</span>


<span class="k">def</span> <span class="nf">get_ham_avg</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">ham_mini_circuits</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute average of the total qubit Hamiltonian.</span>

<span class="sd">    args</span>
<span class="sd">        params           - parameter value for the ansatz circuit</span>
<span class="sd">        ansatz           - ansatz circuit</span>
<span class="sd">        ham_mini_ciruits - pre-built circuits to measure Hamiltonian terms</span>
<span class="sd">        obs              - data for observables</span>
<span class="sd">        shots            - number of shots</span>

<span class="sd">    returns</span>
<span class="sd">        avg   - average of Hamiltonian</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s2">&quot;aer_simulator&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">measure_circuit</span><span class="p">,</span> <span class="n">obsval</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">ham_mini_circuits</span><span class="p">,</span> <span class="n">obs</span><span class="p">):</span>
        <span class="n">total_circuit</span> <span class="o">=</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">measure_circuit</span><span class="p">)</span>
        <span class="n">total_circuit_bind</span> <span class="o">=</span> <span class="n">total_circuit</span><span class="o">.</span><span class="n">bind_parameters</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">total_circuit_bind</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
        <span class="n">paulistring_avg</span> <span class="o">=</span> <span class="n">get_paulistr_avg</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">obsval</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">paulistring_avg</span>

    <span class="k">return</span> <span class="n">avg</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Main program</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>

<span class="c1"># variables</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;θ&quot;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">)),</span>
<span class="p">)</span>
<span class="n">shots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">no_of_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">param_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">no_of_points</span><span class="p">)</span>
<span class="c1"># g_i coeffs for R = 0.75</span>
<span class="n">g_coeff</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3435</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4347</span><span class="p">,</span> <span class="mf">0.5716</span><span class="p">,</span> <span class="mf">0.091</span><span class="p">,</span> <span class="mf">0.091</span><span class="p">]</span>
<span class="n">g_coeff_id</span> <span class="o">=</span> <span class="mf">0.2252</span>
<span class="c1"># graph</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># map outcome states to outcome values</span>
<span class="n">obs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>  <span class="c1"># 1 x Z</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>  <span class="c1"># Z x 1</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1"># Z x Z</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1"># Y x Y</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
<span class="p">]</span>  <span class="c1"># X x X</span>

<span class="c1"># start</span>
<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">create_ansatz_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
<span class="n">ham_mini_circuits</span> <span class="o">=</span> <span class="n">paulis_to_measure_circ</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">)</span>

<span class="c1"># record min val of hamiltonian</span>
<span class="n">h_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span>

<span class="c1"># scan theta domain [-pi, pi]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">param_range</span><span class="p">:</span>
    <span class="n">h_avg</span> <span class="o">=</span> <span class="n">get_ham_avg</span><span class="p">(</span>
        <span class="p">{</span><span class="n">theta</span><span class="p">:</span> <span class="n">x</span><span class="p">},</span> <span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">g_coeff</span><span class="p">,</span> <span class="n">ham_mini_circuits</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">shots</span>
    <span class="p">)</span>
    <span class="n">h_avg</span> <span class="o">+=</span> <span class="n">g_coeff_id</span>  <span class="c1"># add coeff of id term</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_avg</span><span class="p">)</span>  <span class="c1"># collect data for plotting</span>
    <span class="k">if</span> <span class="n">h_avg</span> <span class="o">&lt;</span> <span class="n">h_min</span><span class="p">:</span>  <span class="c1"># record min value</span>
        <span class="n">h_min</span> <span class="o">=</span> <span class="n">h_avg</span>

<span class="c1"># result</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">H_min =&quot;</span><span class="p">,</span> <span class="n">h_min</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>H_min = 0.2252
</pre></div>
</div>
</div>
</div>
<p>The routine <code class="docutils literal notranslate"><span class="pre">get_ham_avg()</span></code> in L105, and more specifically the loop in L122 implements the idea we outlined above. It iterates over all mini-circuits, combining each mini-circuit with the ansatz circuit, running it, collecting the statistics and finally computing the average for the term.</p>
<p>The answer is still wrong because the very last step, computing the average of a single Pauli string in <code class="docutils literal notranslate"><span class="pre">get_paulistr_avg()</span></code> is still not implemented. Let us fill in that too.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">assemble</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Parameter</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Routines</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>
<span class="k">def</span> <span class="nf">create_ansatz_circuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create H2 ansatz circuit given in O&#39;Malley etal 2015.</span>

<span class="sd">    args</span>
<span class="sd">        qreg           - qubits</span>
<span class="sd">        creg           - classical bits</span>
<span class="sd">        parameter      - parameter for parameterized circuit</span>

<span class="sd">    returns</span>
<span class="sd">        ansatz_circuit - a parameterized circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

    <span class="c1"># H2 circuit</span>
    <span class="c1"># 1 - create HF reference state</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="c1"># 2 - ansatz: U(theta)</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># 3</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 4 - parameterized Z-rotation</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 5</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 6</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ansatz_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ansatz_circuit</span>


<span class="k">def</span> <span class="nf">paulis_to_measure_circ</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">,</span> <span class="n">hamlist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate measure circuits from hamiltonian pauli list</span>
<span class="sd">    for measurements in different bases.</span>

<span class="sd">    args</span>
<span class="sd">        qreg     - qubits</span>
<span class="sd">        creg     - classical bits</span>
<span class="sd">        hamlist  - total hamiltonian, i.e. pauli strings</span>

<span class="sd">    returns</span>
<span class="sd">        circuits - list of circuits that can be used to average over</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">hamlist</span><span class="p">:</span>
        <span class="n">minicirc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qubitno</span><span class="p">,</span> <span class="n">qubitop</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">qubitop</span> <span class="o">==</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">sdg</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
                <span class="n">minicirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">qubitno</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Error: INVALID qubit operation&quot;</span>

        <span class="n">minicirc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>
        <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minicirc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuits</span>


<span class="k">def</span> <span class="nf">get_paulistr_avg</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate average of a Pauli string (e.g. IX, XX or YY).</span>

<span class="sd">    args</span>
<span class="sd">        counts      - result of simulation: {&#39;00&#39;: 45, &#39;01&#39;: 34, . . .}</span>
<span class="sd">        obs         - data for calculating probabilities</span>
<span class="sd">        shots       - number of repetitions</span>

<span class="sd">    returns</span>
<span class="sd">        avg         - the average value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">fshots</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">shots</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">avg</span> <span class="o">+=</span> <span class="n">obs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span> <span class="o">/</span> <span class="n">fshots</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">avg</span>


<span class="k">def</span> <span class="nf">get_ham_avg</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">ham_mini_circuits</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute average of the total qubit Hamiltonian.</span>

<span class="sd">    args</span>
<span class="sd">        params           - parameter value for the ansatz circuit</span>
<span class="sd">        ansatz           - ansatz circuit</span>
<span class="sd">        ham_mini_ciruits - pre-built circuits to measure Hamiltonian terms</span>
<span class="sd">        obs              - data for observables</span>
<span class="sd">        shots            - number of shots</span>

<span class="sd">    returns</span>
<span class="sd">        avg   - average of Hamiltonian</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s2">&quot;aer_simulator&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">measure_circuit</span><span class="p">,</span> <span class="n">obsval</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">ham_mini_circuits</span><span class="p">,</span> <span class="n">obs</span><span class="p">):</span>
        <span class="n">total_circuit</span> <span class="o">=</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">measure_circuit</span><span class="p">)</span>
        <span class="n">total_circuit_bind</span> <span class="o">=</span> <span class="n">total_circuit</span><span class="o">.</span><span class="n">bind_parameters</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">total_circuit_bind</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
        <span class="n">paulistring_avg</span> <span class="o">=</span> <span class="n">get_paulistr_avg</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">obsval</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">paulistring_avg</span>

    <span class="k">return</span> <span class="n">avg</span>


<span class="c1">##########################################################</span>
<span class="c1">#</span>
<span class="c1">#  Main program</span>
<span class="c1">#</span>
<span class="c1">##########################################################</span>

<span class="c1"># variables</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;θ&quot;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">)),</span>
<span class="p">)</span>
<span class="n">shots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">no_of_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">param_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">no_of_points</span><span class="p">)</span>
<span class="c1"># g_i coeffs for R = 0.75</span>
<span class="n">g_coeff</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3435</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4347</span><span class="p">,</span> <span class="mf">0.5716</span><span class="p">,</span> <span class="mf">0.091</span><span class="p">,</span> <span class="mf">0.091</span><span class="p">]</span>
<span class="n">g_coeff_id</span> <span class="o">=</span> <span class="mf">0.2252</span>
<span class="c1"># graph</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># map outcome states to outcome values</span>
<span class="n">obs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>  <span class="c1"># 1 x Z</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>  <span class="c1"># Z x 1</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1"># Z x Z</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1"># Y x Y</span>
    <span class="p">{</span><span class="s2">&quot;00&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;01&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
<span class="p">]</span>  <span class="c1"># X x X</span>

<span class="c1"># start</span>
<span class="n">ansatz_circuit</span> <span class="o">=</span> <span class="n">create_ansatz_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
<span class="n">ham_mini_circuits</span> <span class="o">=</span> <span class="n">paulis_to_measure_circ</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">)</span>

<span class="c1"># record min val of hamiltonian</span>
<span class="n">h_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span>

<span class="c1"># scan theta domain [-pi, pi]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">param_range</span><span class="p">:</span>
    <span class="n">h_avg</span> <span class="o">=</span> <span class="n">get_ham_avg</span><span class="p">(</span>
        <span class="p">{</span><span class="n">theta</span><span class="p">:</span> <span class="n">x</span><span class="p">},</span> <span class="n">ansatz_circuit</span><span class="p">,</span> <span class="n">g_coeff</span><span class="p">,</span> <span class="n">ham_mini_circuits</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">shots</span>
    <span class="p">)</span>
    <span class="n">h_avg</span> <span class="o">+=</span> <span class="n">g_coeff_id</span>  <span class="c1"># add coeff of id term</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_avg</span><span class="p">)</span>  <span class="c1"># collect data for plotting</span>
    <span class="k">if</span> <span class="n">h_avg</span> <span class="o">&lt;</span> <span class="n">h_min</span><span class="p">:</span>  <span class="c1"># record min value</span>
        <span class="n">h_min</span> <span class="o">=</span> <span class="n">h_avg</span>

<span class="c1"># result</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">H_min =&quot;</span><span class="p">,</span> <span class="n">h_min</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>H_min = -1.1556946
</pre></div>
</div>
</div>
</div>
<p>This result is now close to the result obtained in <code class="docutils literal notranslate"><span class="pre">arXiv:1512.06860v2</span></code> where the circuit was executed on a real, physical quantum computer—compare it with the result in the paper in Fig. 3 at bond length <span class="math notranslate nohighlight">\(R = 0.75\)</span>.</p>
</section>
<section id="further-problems">
<h3><strong>Further problems</strong><a class="headerlink" href="#further-problems" title="Link to this heading">#</a></h3>
<p>The article <code class="docutils literal notranslate"><span class="pre">arXiv:1512.06860v2</span></code> contains several figures that visualize the results in more detail. Using the above code, you can reproduce them with a little more work. This will give a better understanding of how VQE works.</p>
<blockquote>
<div><p><strong>Exercise 1</strong>. Record the average of each Hamiltonian term at <span class="math notranslate nohighlight">\(R = 0.75\)</span> and plot the averages. The resulting graph should be similar to Fig. 2a in <code class="docutils literal notranslate"><span class="pre">arXiv:1512.06860v2</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p><strong>Exercise 2</strong>. Extend the program to find the minimum energies at all bond lengths given in Table 1 in the Appendix. Plot the resulting graph. It should look like Fig. 3a in <code class="docutils literal notranslate"><span class="pre">arXiv:1512.06860v2</span></code>.</p>
</div></blockquote>
</section>
</section>
<section id="summary">
<h2><strong>Summary</strong><a class="headerlink" href="#summary" title="Link to this heading">#</a></h2>
<p>In this session, we have given an implementation of the VQE algorithm for the <span class="math notranslate nohighlight">\(H_2\)</span> molecule based on the circuit and the data in <code class="docutils literal notranslate"><span class="pre">arXiv:1512.06860v2</span></code>.</p>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="E2_optimization.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><strong>Use case: Optimization</strong></p>
      </div>
    </a>
    <a class="right-next"
       href="quito.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Quantum software testing with Quito</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-session-implement-vqe-for-h-2"><strong>Practice session: implement VQE for <span class="math notranslate nohighlight">\(H_2\)</span></strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis"><strong>Synopsis</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation"><strong>Implementation</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#measure-expectation-values"><strong>Measure Expectation values</strong></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scan-the-parameter-interval"><strong>Scan the parameter interval</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mapping-outcome-states-to-values"><strong>Mapping outcome states to values</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#further-problems"><strong>Further problems</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary"><strong>Summary</strong></a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By NordIQuEst
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, NordIQuEst.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>