
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Tutorial - Estimating the Surface Code Threshold &#8212; NordIQuEst Application Library</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_lesson.css?v=e9df6548" />
    <link rel="stylesheet" type="text/css" href="../../../_static/term_role_formatting.css?v=4194e21c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/minipres.js?v=a0d29692"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>window.MathJax = {"tex": {"macros": {"vr": "\\vec{r}", "ket": ["\\left| #1 \\right\\rangle", 1], "bra": ["\\left| #1 \\right\\langle", 1], "iprod": ["\\left\\langle #1 | #2 \\right\\rangle", 2]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'training-material/qas2024/notebooks/surface_code_threshold';</script>
    <link rel="icon" href="../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Slides" href="../slides/index.html" />
    <link rel="prev" title="Tutorial - Variational Quantum Algorithms" href="qaoa_exercise.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/nq_logo2.png" class="logo__image only-light" alt="NordIQuEst Application Library - Home"/>
    <script>document.write(`<img src="../../../_static/nq_logo2.png" class="logo__image only-dark" alt="NordIQuEst Application Library - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Application Library</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../README.html"><strong>NordIQuEst Application Library</strong></a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../hybrid-algorithms/index.html"><strong>Hybrid Algorithms</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/QAOA/index.html">Quantum Approximate Optimization Algorithm (QAOA)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/QAOA/MaxCut.html">Comparison of Different Optimizers for QAOA on a Max Cut instance</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Chemistry/index.html">Quantum Chemistry</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Chemistry/Installation.html">Installation instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Chemistry/Theory.html">Theory: Quantum Chemistry on Quantum Computers</a></li>

<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Chemistry/VQE.html">Notebook example: VQE</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Walk/index.html">Quantum Walk</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Walk/ClassicalRandomWalk.html">Classical Random Walk on a Quantum Computer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/Quantum%20Walk/QuantumRandomWalk.html">Quantum Random Walk on a Quantum Computer</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/VQE/index.html">Variational Quantum Eigensolver (VQE) Tutorial</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/VQE/vqe-h2-cirq.html">Cirq: Variational Quantum Eigensolver for <span class="math notranslate nohighlight">\(H_2\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/VQE/vqe-h2-qiskit.html">Qiskit: Variational Quantum Eigensolver for <span class="math notranslate nohighlight">\(H_2\)</span></a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../hybrid-algorithms/QuantumReservoirComputing/index.html">Quantum Reservoir Computing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../hybrid-algorithms/QuantumReservoirComputing/Logistic%20map.html">Quantum Reservoir Computing: Logistic map</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../real-devices/index.html"><strong>Real Devices</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../real-devices/ex3-qal9000-demo/index.html">ex3-qal9000 Demo</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../real-devices/ex3-qal9000-demo/compute-bloch-frames.html">ex3-qal9000 Demo: StateTomography on QAL9000</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="../../../real-devices/intro-to-helmi-qiskit.html">Introduction to Helmi with Qiskit</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../simulators/index.html"><strong>Simulators</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../simulators/ex3/index.html">ex3 Simulators</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/ex3/qiskit/README.html">Running Quantum programs on the Qiskit Simulator in eX3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/ex3/qsim/README.html">QSIM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/ex3/QuEST/README.html">Guide of Running QuEST in eX3</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../simulators/lumi/index.html">LUMI Simulators</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../simulators/lumi/qiskit/index.html">Qiskit</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../simulators/lumi/qiskit/v0.12.0/README.html">v0.12.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../simulators/lumi/qiskit/v1.1.1/README.html">v1.1.1</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/lumi/qsim/README.html">QSim</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../simulators/lumi/QuEST/README.html">QuEST</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../../index.html"><strong>Training Material Archive</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="../../qas2022/index.html">Quantum Autumn School 2022</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../qas2022/notebooks/index.html">Notebooks</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/notebooks/E1_qc-1.html"><strong>Quantum programming I</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/notebooks/E1_qc-2.html"><strong>Quantum programming II</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/notebooks/E1_qc-3.html"><strong>Quantum programming III</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/notebooks/E2_optimization.html"><strong>Use case: Optimization</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/notebooks/E2_VQE-H2.html"><strong>Use case: Quantum chemistry</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/notebooks/quito.html">Quantum software testing with Quito</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../qas2022/slides/index.html">Slides</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/slides/landscape.html">The HPC-QC landscape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/slides/qc_hardware.html">Overview of different QC hardware approaches and QC types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/slides/programming_qc.html">Introduction to high-level languages for QC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/slides/hybrid_hpc_qc.html">The hybrid HPC-QC approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/slides/software_stack_overview.html">Overview of the software stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/slides/hybrid_algorithms.html">Hybrid classical/quantum algorithms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2022/slides/qc_testing.html">Quantum software testing</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../qas2023/index.html">Quantum Autumn School 2023</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../qas2023/notebooks/index.html">Notebooks</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/E2_VQE-H2.html">Tutorial - Quantum chemistry</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/intro-to-helmi-qiskit.html">Tutorial - Introduction to Helmi with qiskit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/Notebook_maxcut_Qas2023.html">Tutorial - Quantum Alternating Operator Ansatz</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/Notebook_maxcut_Qas2023_sol.html">Solutions - Tutorial - Quantum Alternating Operator Ansatz</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/notebooks/Qubit_Spectroscopy_Analysis.html">Tutorial - Qubit Spectroscopy Analysis</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../qas2023/slides/index.html">Slides</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/slides/hpc-qc.html">HPC-QC integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/slides/software-stack.html">QC software stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../qas2023/slides/hybrid-classical-quantum.html">Hybrid Classical/Quantum Algorithms</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../neic2024-qc101/index.html">NeIC 2024 Workshop: Quantum Computing 101</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../neic2024-qc101/setup.html">Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../neic2024-qc101/notebooks/introduction-to-using-a-qc.html"><strong>Workshop: Quantum Computing 101 Part I</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../neic2024-qc101/notebooks/introduction-to-using-a-qc-2.html"><strong>Workshop: Quantum Computing 101 Part II</strong></a></li>
</ul>
</details></li>
<li class="toctree-l2 current active has-children"><a class="reference internal" href="../index.html">Quantum Autumn School 2024</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l3 current active has-children"><a class="reference internal" href="index.html">Notebooks</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="css_code_steane.html">Tutorial - Fault-Tolerant Quantum Computing with CSS codes</a></li>
<li class="toctree-l4"><a class="reference internal" href="decoding_excercise.html">Tutorial - MAP Decoding Exercise</a></li>
<li class="toctree-l4"><a class="reference internal" href="flight_scheduling_optimization_qaoa.html">Tutorial - Solving Flight Scheduling Optimization using QAOA</a></li>
<li class="toctree-l4"><a class="reference internal" href="ghz_estimator_attendees.html">Tutorial - Introduction to Helmi</a></li>
<li class="toctree-l4"><a class="reference internal" href="option_pricing_tutorial.html">Tutorial - Pricing a European call option using quantum computing</a></li>
<li class="toctree-l4"><a class="reference internal" href="option_pricing.html">Tutorial - Pricing a European call option on a quantum computer</a></li>
<li class="toctree-l4"><a class="reference internal" href="qaoa_exercise.html">Tutorial - Variational Quantum Algorithms</a></li>
<li class="toctree-l4 current active"><a class="current reference internal" href="#">Tutorial - Estimating the Surface Code Threshold</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../slides/index.html">Slides</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-integration-hpc-qc.html">Integration of High Performance Computing and Quantum Computing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-mat-sci-on-qc.html">Quantum Computing for Materials Science</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-tergite-overview.html">Tergite Software Stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-intro-helmi.html">Introduction to Helmi</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-quantum-walks.html">Quantum walks on quantum computers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-qelm-case-study.html">Quantum Extreme Learning Machine: Case Studies on Software Testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-quantum-option-pricing.html">Option pricing on a quantum computer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-quantum-error-correction.html">Quantum Error Correction: Theory and Hands-on</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-distributed-quantum-computing.html">Distributed Quantum Computing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-amplitude-estimation.html">Quantum Amplitude Estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-qsip-innovation-platform.html">Quantum Sweden Innovation Platform</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-vqe-and-qaoa.html">Introduction to variational quantum algorithms: VQE and QAOA</a></li>
<li class="toctree-l4"><a class="reference internal" href="../slides/qas24-ncc-hpc-ai-iceland.html">Icelandic National Competence Center (NCC) for HPC &amp; AI – Quantum Computing Activities</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../testing-tools/index.html"><strong>Quantum Software Testing Tools</strong></a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../testing-tools/README.html">Run Software Testing Tools on Jupyter Notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../testing-tools/tutorial_quito.html">Welcome to Quito!</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../testing-tools/tutorial_qusbt.html">Welcome to QuSBT!</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../testing-tools/tutorial_qucat.html">Welcome to QuCAT!</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Information</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../docs/authors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/acknowledgement.html">Acknowledgement</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/NordIQuEst/application-library" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/training-material/qas2024/notebooks/surface_code_threshold.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Tutorial - Estimating the Surface Code Threshold</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#python-dependencies">Python Dependencies</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-surface-code">The Surface Code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#surface-code-circuit-in-stim">Surface Code Circuit in Stim</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#circuit-metadata">Circuit Metadata</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#detectors">Detectors</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#final-measurement-round">Final Measurement Round</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#detectors-in-the-absence-of-noise">Detectors in the Absence of Noise</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#noisy-surface-code-circuits">Noisy Surface Code Circuits</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-detector-error-model-dem">The Detector Error Model (DEM)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-dem-for-repetition-code">Example: DEM for Repetition Code</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dem-model-and-the-tanner-graph">DEM model and the Tanner Graph</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dem-model-for-decoder-research-and-reproducibility">DEM model for Decoder Research and Reproducibility</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#decoding-errors-minimum-weight-perfect-matching">Decoding Errors: Minimum-Weight Perfect Matching</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#estimating-the-repetition-code-threshold">Estimating the Repetition Code Threshold</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-estimating-the-threshold-of-the-surface-code">Exercise: Estimating the Threshold of the Surface Code</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="tutorial-estimating-the-surface-code-threshold">
<h1>Tutorial - Estimating the Surface Code Threshold<a class="headerlink" href="#tutorial-estimating-the-surface-code-threshold" title="Link to this heading">#</a></h1>
<p>In this notebook, we will estimate the threshold of the Surface Code, for a simple phenomenological circuit-noise model.</p>
<section id="python-dependencies">
<h2>Python Dependencies<a class="headerlink" href="#python-dependencies" title="Link to this heading">#</a></h2>
<p>To run the Jupyter Notebook locally, you’ll need the following dependencies:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>stim~<span class="o">=</span><span class="m">1</span>.14
numpy~<span class="o">=</span><span class="m">1</span>.0<span class="w">  </span><span class="c1"># require for PyMatching</span>
scipy
pymatching
matplotlib
</pre></div>
</div>
<p>If not already installed in your environmnet you can install them with</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>stim~<span class="o">=</span><span class="m">1</span>.14<span class="w"> </span>numpy~<span class="o">=</span><span class="m">1</span>.0<span class="w"> </span>scipy<span class="w"> </span>pymatching<span class="w"> </span>matplotlib
</pre></div>
</div>
</section>
<section id="the-surface-code">
<h2>The Surface Code<a class="headerlink" href="#the-surface-code" title="Link to this heading">#</a></h2>
<p>As discussed in the lecture, the Surface Code is a stabilizer code with code distance <span class="math notranslate nohighlight">\(d\)</span>, <span class="math notranslate nohighlight">\(d^2\)</span> data qubits, and <span class="math notranslate nohighlight">\(d^2-1\)</span> syndrome measurement qubits, embedded in a 2D-plane.</p>
<p>The stabilizers of the code have weight 4 (interior) or 2 (boundary) depending on their location on the surface. In the picture below, a distance <span class="math notranslate nohighlight">\(d=5\)</span> Surface Code is shown. The red squares depict the <span class="math notranslate nohighlight">\(X\)</span>-type stabilizers, and the blue squares depict the <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizers.</p>
<p><img alt="Surface Code" src="../../../_images/surface-code.svg" /></p>
<p><strong>Source:</strong> https://errorcorrectionzoo.org/c/rotated_surface</p>
<p>To measure the syndromes, the code requires only local operation between neighboring qubits since each syndrome qubit measures only its neighboring data qubits.</p>
</section>
<section id="surface-code-circuit-in-stim">
<h2>Surface Code Circuit in Stim<a class="headerlink" href="#surface-code-circuit-in-stim" title="Link to this heading">#</a></h2>
<p>We will use the stabilizer simulator <a class="reference external" href="https://github.com/quantumlib/Stim"><code class="docutils literal notranslate"><span class="pre">Stim</span></code></a> to simulate the circuit code execution and the circuit noise.</p>
<p>Stim allows us to load a set of pre-defined quantum circuits for well-known quantum error correction codes such as the Surface Code.</p>
<p>We’ll start by generating a distance <span class="math notranslate nohighlight">\(d=3\)</span> Surface Code quantum circuits with 3 rounds of syndrome measurements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">stim</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span><span class="s2">&quot;surface_code:rotated_memory_x&quot;</span><span class="p">,</span> <span class="n">rounds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeline-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>For <span class="math notranslate nohighlight">\(d=3\)</span>, we expect the circuit to have 9 data qubits and 8 ancilla qubits to measure the stabilizers, so a total of 15 qubits. The cirucit generated above contains a few idle wires (corresponding to unused qubits).</p>
<p>A better way to see which qubits are actually utilized is to print a <strong>timeslice diagram</strong> of the circuit. A timeslice diagram depicts the parts of the circuit executed between two <code class="docutils literal notranslate"><span class="pre">TICK</span></code> operations.</p>
<p><code class="docutils literal notranslate"><span class="pre">stim</span></code> automatically injects <code class="docutils literal notranslate"><span class="pre">TICK</span></code> operations so that we can easily follow the code circuit execution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeslice-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can see that in each round of syndrome measurement, 4 blocks of parallel CNOT gates are applied. In each block, 6 CNOTs are executed - 4 for the stabilizers in the interior of the surface and 2 for the stabilizers at the boundary measuring 2 data qubits.</p>
<p><strong>Note:</strong> The CNOT gates are executed in a specific order to avoid <strong>hook errors</strong>, which would spread low-weight Pauli errors, to higher weight Pauli errors, making fault-tolerant operations impossible!</p>
<p>After each round, the ancillas are measured, extracting the stabilizer Eigenvalues, followed by a reset operation to re-use them for the next round of error detection.</p>
<section id="circuit-metadata">
<h3>Circuit Metadata<a class="headerlink" href="#circuit-metadata" title="Link to this heading">#</a></h3>
<p>In the circuit above, we can see two other annotations, besides the <code class="docutils literal notranslate"><span class="pre">TICK</span></code> operation, which do not correspond to quantum gates operating on the qubits.</p>
<p>The first 16 instructions of the circuit use the <code class="docutils literal notranslate"><span class="pre">QUBIT_COORDS(x,</span> <span class="pre">y)</span> <span class="pre">qubit_index</span></code> annotation to provide Stim information about the qubit’s location in space. This information is utilized by various tools to visualize the circuit execution such as the <code class="docutils literal notranslate"><span class="pre">timeslice</span></code> visualizer.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The second annotiation is the <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> annotation which is discussed in the next section.</p>
</section>
<section id="detectors">
<h3>Detectors<a class="headerlink" href="#detectors" title="Link to this heading">#</a></h3>
<p>We can see that Stim appended to the end of each QEC cycle a bunch of <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> statements.</p>
<p>A detector is a parity check, based on a set of measurements in the <strong>measurement record</strong> denoted as <code class="docutils literal notranslate"><span class="pre">rec</span></code>. Under noiseless execution, the <strong>parity of the detector should never change</strong>.</p>
<p>The latest measurement in the measurement recored is accessible through <code class="docutils literal notranslate"><span class="pre">rec[-1]</span></code>.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> can be assigned a location in space-time via a triplet of coordinates (<span class="math notranslate nohighlight">\(x,y,z\)</span>), which can later be used to display a space-time graph.</p>
<p>If we print the instructions for the first QEC cycle, we see that 4 detectors have been added. Those are used for the <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizer parity checks, detecting Pauli-<span class="math notranslate nohighlight">\(X\)</span> errors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instructions for the first QEC cycle</span>
<span class="n">circuit</span><span class="p">[</span><span class="mi">17</span><span class="p">:</span><span class="mi">37</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>What about the <span class="math notranslate nohighlight">\(X\)</span>-type stabilizers?</p>
<p>Since at the beginning of the circuit we prepared our qubits in the <span class="math notranslate nohighlight">\(\ket{1}\)</span> state, they are already Eigenvectors of all <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizers resulting in a deterministic measurement (<span class="math notranslate nohighlight">\(Z\)</span>-type stabilizers have an even amount of Pauli-<span class="math notranslate nohighlight">\(Z\)</span> operators cancelling out the phase-flip of <span class="math notranslate nohighlight">\(-1\)</span> for single physical qubits).</p>
<p><strong>Example:</strong> <span class="math notranslate nohighlight">\(ZZZZ\ket{1}\ket{1}\ket{1}\ket{1} = (-1)^4 \ket{1}\ket{1}\ket{1}\ket{1} = \ket{1}\ket{1}\ket{1}\ket{1}\)</span></p>
<p>For the <span class="math notranslate nohighlight">\(X\)</span>-type stabilizers, we require an initial measurement round projecting them randomly onto one of the 2 Eigenspaces <span class="math notranslate nohighlight">\(+1\)</span>/<span class="math notranslate nohighlight">\(-1\)</span>. Subsequent measurements, in the absence of noise, should always yield the same Eigenvalues when measuring the stabilizers.</p>
<p>Therefore, we can add additional <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> statements for the <span class="math notranslate nohighlight">\(X\)</span>-type stabilizers after the second round of measurements as shown below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">[</span><span class="mi">37</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>In the second round, we bitwise XOR the measurement results of the first round, with the measurements of the second round.
This way, <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> events inform the decoder about changes in the syndromes in the presence of noise.</p>
<p><strong>Note:</strong> The <code class="docutils literal notranslate"><span class="pre">SHIFT_COORDS</span></code> instruction can be used to shift the <span class="math notranslate nohighlight">\(z\)</span>-index (time) by 1, which allows us to to reuse the same detector coordinates in every QEC cycle.</p>
</section>
<section id="final-measurement-round">
<h3>Final Measurement Round<a class="headerlink" href="#final-measurement-round" title="Link to this heading">#</a></h3>
<p>At the end of the circuit, all physical data qubits are measured destructively in the <span class="math notranslate nohighlight">\(X\)</span>-basis, and detectors computing <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizer parities are defined.</p>
<p>Finally, we define the logical observable measurement as the parity of physical qubits <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(8\)</span>, and <span class="math notranslate nohighlight">\(15\)</span>, corresponding to a logical <span class="math notranslate nohighlight">\(X_L\)</span> measurement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">[</span><span class="mi">60</span><span class="p">::]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="detectors-in-the-absence-of-noise">
<h3>Detectors in the Absence of Noise<a class="headerlink" href="#detectors-in-the-absence-of-noise" title="Link to this heading">#</a></h3>
<p>Without any noise in the circuit, our detectors and the logical observable should always measure the same parities.</p>
<p>We can put this to the test by, compiling a <code class="docutils literal notranslate"><span class="pre">sampler</span></code> which will simulate the circuit and collect detector events.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define a detector sampler</span>
<span class="n">sampler</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">compile_detector_sampler</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Sample detection events and logical observable</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">detection_events</span><span class="p">,</span> <span class="n">observable_flips</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">shots</span><span class="p">,</span> <span class="n">separate_observables</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Below we can see that the detection events never change parity</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">detection_events</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The same applies to the observable</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">observable_flips</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="noisy-surface-code-circuits">
<h3>Noisy Surface Code Circuits<a class="headerlink" href="#noisy-surface-code-circuits" title="Link to this heading">#</a></h3>
<p>Now, that we understand how the Surface Code circuit looks like and how detectors behave, we can explore what happens when noise is added to the mix.</p>
<p>Stim doesn’t support a noise model, like the ones Qiskit or Cirq support, but we can easily generate the same Surface Code circuit with noisy gates injected.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noisy_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
    <span class="s2">&quot;surface_code:rotated_memory_x&quot;</span><span class="p">,</span>
    <span class="n">rounds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">distance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">after_clifford_depolarization</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="n">after_reset_flip_probability</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="n">before_measure_flip_probability</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="n">before_round_data_depolarization</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The cirucit contains now noise operations, simulating qubit reset, measurement and gate errors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noisy_circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeline-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With the noise, we observe for the first time logical errors after measuring the logical observable</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">shots</span> <span class="o">=</span> <span class="mi">10_000</span>

<span class="n">sampler</span> <span class="o">=</span> <span class="n">noisy_circuit</span><span class="o">.</span><span class="n">compile_detector_sampler</span><span class="p">()</span>
<span class="n">detection_events</span><span class="p">,</span> <span class="n">observable_flips</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">shots</span><span class="p">,</span> <span class="n">separate_observables</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Success rate after 1 QEC cycle: </span><span class="si">{</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">observable_flips</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">shots</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2"> %&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We also observe detection events in the measured data, indicating the presence of errors:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">detection_events</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="the-detector-error-model-dem">
<h2>The Detector Error Model (DEM)<a class="headerlink" href="#the-detector-error-model-dem" title="Link to this heading">#</a></h2>
<p>Our goal is to decode the Surface Code. In this section, we introduce a useful abstraction, called the <strong>detector error model (DEM)</strong> which we will use for decoding.</p>
<p>Given a set of measurement parities, defined through detectors and logical observables in the circuit, the detector error model informs the decoder with which probability any of the checks fails due to an error.</p>
<p>For our noisy Surface Code circuit, we can compile a detector model and print the DEM model representation</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dem</span> <span class="o">=</span> <span class="n">noisy_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dem</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The first instruction</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">error</span><span class="p">(</span><span class="mf">0.00193118</span><span class="p">)</span> <span class="n">D0</span> <span class="n">D2</span>
</pre></div>
</div>
<p>tells us, that there is some error mechanism in our circuit, that occurs with probability <span class="math notranslate nohighlight">\(0.00193118\)</span> and that will flip the parities of both detectors <code class="docutils literal notranslate"><span class="pre">D0</span></code> and <code class="docutils literal notranslate"><span class="pre">D2</span></code>, defined as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">detector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="n">D0</span>
<span class="n">detector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="n">D2</span>
</pre></div>
</div>
<p>in our Surface Code circuit. As a reminder: Detectors are directly associated with stabilizer measurements. This means, that the error probability tells us with which probability a stabilizer measurement will fail given the circuit-level noise model.</p>
<section id="example-dem-for-repetition-code">
<h3>Example: DEM for Repetition Code<a class="headerlink" href="#example-dem-for-repetition-code" title="Link to this heading">#</a></h3>
<p>Since our noisy Surface Code has many source of errors, retracing the source of error probabilities in the DEM is not a simple task.</p>
<p>Instead, let’s continue our analysis for the <span class="math notranslate nohighlight">\(X\)</span>-flip repetition code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetition_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    X_ERROR(0.1) 0 1 2</span>
<span class="s2">    CNOT 0 3 1 3 1 4 2 4</span>
<span class="s2">    MR 3 4</span>
<span class="s2">    DETECTOR(0,0,0) rec[-1]</span>
<span class="s2">    DETECTOR(0,0,0) rec[-2]</span>
<span class="s2">  &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetition_circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeline-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The corresponding DEM has the following form</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dem</span> <span class="o">=</span> <span class="n">repetition_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dem</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Unsurprisingly, there are three possible errors affecting our detectors. Since both detectors measure the second qubit they will be flipped with probability <span class="math notranslate nohighlight">\(0.1\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">error</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="n">D0</span> <span class="n">D1</span>
</pre></div>
</div>
<p>Adding Pauli-<span class="math notranslate nohighlight">\(Z\)</span> errors to our circuit does not affect the DEM as the repetition code cannot detect them:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetition_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    X_ERROR(0.1) 0 1 2</span>
<span class="s2">    Z_ERROR(0.1) 0 1 2</span>
<span class="s2">    CNOT 0 3 1 3 1 4 2 4</span>
<span class="s2">    MR 3 4</span>
<span class="s2">    DETECTOR(0,0,0) rec[-1]</span>
<span class="s2">    DETECTOR(0,0,0) rec[-2]</span>
<span class="s2">  &quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">dem</span> <span class="o">=</span> <span class="n">repetition_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dem</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Replacing the Pauli-<span class="math notranslate nohighlight">\(X\)</span> and Pauli-<span class="math notranslate nohighlight">\(Z\)</span> errors by depolarizing noise, results in the following DEM:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetition_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    DEPOLARIZE1(0.1) 0 1 2</span>
<span class="s2">    CNOT 0 3 1 3 1 4 2 4</span>
<span class="s2">    MR 3 4</span>
<span class="s2">    DETECTOR(0,0,0) rec[-1]</span>
<span class="s2">    DETECTOR(0,0,0) rec[-2]</span>
<span class="s2">  &quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">dem</span> <span class="o">=</span> <span class="n">repetition_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dem</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>For depolarizing noise with probability <span class="math notranslate nohighlight">\(p\)</span>, Stim applies a given Pauli gate with  probability:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(I\)</span>: <span class="math notranslate nohighlight">\((1-p)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span>: <span class="math notranslate nohighlight">\(\frac{p}{3}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(Y\)</span>: <span class="math notranslate nohighlight">\(\frac{p}{3}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(Z\)</span>: <span class="math notranslate nohighlight">\(\frac{p}{3}\)</span></p></li>
</ul>
<p>Therefore, we have a probability of <span class="math notranslate nohighlight">\(\frac{2p}{3}\)</span> that our detectors are flipped as we only need to take into account Pauli-<span class="math notranslate nohighlight">\(X\)</span> and Pauli-<span class="math notranslate nohighlight">\(Y\)</span> errors.</p>
</section>
<section id="dem-model-and-the-tanner-graph">
<h3>DEM model and the Tanner Graph<a class="headerlink" href="#dem-model-and-the-tanner-graph" title="Link to this heading">#</a></h3>
<p>The detector errror model represents a weighted graph, where the nodes are parity checks and the weights represent independent error probabilities affecting the checks.</p>
<p>This representation is very natural for decoders operating on a Tanner graph such as the <strong>Minimum-Weight Perfect Matching</strong> decoder introduced in the lecture.</p>
<p>To further emphasize the relationship, we can visualize the DEM of a larger repetition code using Stim:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
    <span class="s2">&quot;repetition_code:memory&quot;</span><span class="p">,</span>
    <span class="n">rounds</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">distance</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
    <span class="n">before_round_data_depolarization</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span>
    <span class="n">before_measure_flip_probability</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeline-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dem</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="n">dem</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;matchgraph-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The matching graph is a 2D space-time graph. The <span class="math notranslate nohighlight">\(x\)</span>-axis represents space and the <span class="math notranslate nohighlight">\(y\)</span>-axis time.</p>
<p>At each time step, we count 8 vertices, representing the 8 detectors. Furthermore, we have two invisible boundary nodes, for matching errors on the outer qubits, which are only measured by a single detector.</p>
<p>For analyzing the Surface Code DEM, it is usually simpler to print the graph in 3D</p>
<p><strong>Exercise 1:</strong> Test different error mechanisms and see how they affect the connectivity in the DEM graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noisy_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
    <span class="s2">&quot;surface_code:rotated_memory_x&quot;</span><span class="p">,</span>
    <span class="n">rounds</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">distance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="c1"># before_round_data_depolarization=0.001,</span>
    <span class="n">after_reset_flip_probability</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="n">before_measure_flip_probability</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">dem</span> <span class="o">=</span> <span class="n">noisy_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="n">dem</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;matchgraph-3d&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="dem-model-for-decoder-research-and-reproducibility">
<h3>DEM model for Decoder Research and Reproducibility<a class="headerlink" href="#dem-model-for-decoder-research-and-reproducibility" title="Link to this heading">#</a></h3>
<p>Besides being a powerful abstraction, a DEM model is also very useful for sharing noise models.</p>
<p>DEM model errors can be measured on a real device and loaded into Stim, making Stim a powerful tool for evaluating decoders even without access to actual hardware.</p>
<p>DEM models for Google’s recent paper: <a class="reference external" href="https://arxiv.org/html/2408.13687v1#S11"><em>Quantum Error Correction Below the Surface Code Threshold</em></a> can be found on <a class="reference external" href="https://zenodo.org/records/13273331">Zenodo</a></p>
</section>
</section>
<section id="decoding-errors-minimum-weight-perfect-matching">
<h2>Decoding Errors: Minimum-Weight Perfect Matching<a class="headerlink" href="#decoding-errors-minimum-weight-perfect-matching" title="Link to this heading">#</a></h2>
<p>Given a DEM model, it is straightforward to feed the graph and detector events to a minimum-weight perfect matching decoder.</p>
<p>In this tutorial, we are going to use a MWPM implementation called <a class="reference external" href="https://arxiv.org/abs/2105.13082"><code class="docutils literal notranslate"><span class="pre">PyMatching</span></code></a>, developed by Oscar Higgots.</p>
<p>We’ll begin by instantiating a noisy repetition circuit in Stim:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instantiate noisy repetition code</span>
<span class="n">noisy_repetition_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
    <span class="s2">&quot;repetition_code:memory&quot;</span><span class="p">,</span>
    <span class="n">rounds</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">distance</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
    <span class="n">before_round_data_depolarization</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span>
    <span class="n">before_measure_flip_probability</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Instantiate a sampler to sample detector events</span>
<span class="n">sampler</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">compile_detector_sampler</span><span class="p">()</span>

<span class="c1"># Sample detection events and observable flips</span>
<span class="n">num_shots</span> <span class="o">=</span> <span class="mi">10_000</span>
<span class="n">detection_events</span><span class="p">,</span> <span class="n">observable_flips</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">num_shots</span><span class="p">,</span> <span class="n">separate_observables</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Success rate after 25 QEC cycles: &quot;</span>
    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">observable_flips</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_shots</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2"> %&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we import <code class="docutils literal notranslate"><span class="pre">PyMatching</span></code> and use its bindings to construct a graph from our DEM and return predictions given detection events.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pymatching</span>

<span class="c1"># generate DEM for noisy circuit</span>
<span class="n">detector_error_model</span> <span class="o">=</span> <span class="n">noisy_repetition_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">(</span>
    <span class="n">decompose_errors</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="c1"># Istantiate MWPM decoder</span>
<span class="n">matcher</span> <span class="o">=</span> <span class="n">pymatching</span><span class="o">.</span><span class="n">Matching</span><span class="o">.</span><span class="n">from_detector_error_model</span><span class="p">(</span><span class="n">detector_error_model</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can print some metadata about the decoder</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of detectors:&quot;</span><span class="p">,</span> <span class="n">matcher</span><span class="o">.</span><span class="n">num_detectors</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of nodes:&quot;</span><span class="p">,</span> <span class="n">matcher</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of edges: &quot;</span><span class="p">,</span> <span class="n">matcher</span><span class="o">.</span><span class="n">num_edges</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we are ready to decode our sampled data!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">predictions</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">decode_batch</span><span class="p">(</span><span class="n">detection_events</span><span class="p">)</span>
<span class="c1"># print(predictions)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we need to count the decoding mistakes</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Count the mistakes.</span>
<span class="n">num_errors</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">shot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shots</span><span class="p">):</span>
    <span class="n">actual_for_shot</span> <span class="o">=</span> <span class="n">observable_flips</span><span class="p">[</span><span class="n">shot</span><span class="p">]</span>
    <span class="n">predicted_for_shot</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[</span><span class="n">shot</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">actual_for_shot</span><span class="p">,</span> <span class="n">predicted_for_shot</span><span class="p">):</span>
        <span class="n">num_errors</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of errors for </span><span class="si">{</span><span class="n">num_shots</span><span class="si">}</span><span class="s2"> shots: </span><span class="si">{</span><span class="n">num_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="estimating-the-repetition-code-threshold">
<h2>Estimating the Repetition Code Threshold<a class="headerlink" href="#estimating-the-repetition-code-threshold" title="Link to this heading">#</a></h2>
<p>In order to calculate the threshold of a code for a fixed noise model and decoder, we need to evaluate the decoder at different code distances <span class="math notranslate nohighlight">\(d\)</span> and noise-levels <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>We start by writing a function that automates the steps we performed above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">count_logical_errors</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">num_shots</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Sample the circuit.</span>
    <span class="n">sampler</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">compile_detector_sampler</span><span class="p">()</span>
    <span class="n">detection_events</span><span class="p">,</span> <span class="n">observable_flips</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="n">num_shots</span><span class="p">,</span> <span class="n">separate_observables</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Configure a decoder using the circuit.</span>
    <span class="n">detector_error_model</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">(</span><span class="n">decompose_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">matcher</span> <span class="o">=</span> <span class="n">pymatching</span><span class="o">.</span><span class="n">Matching</span><span class="o">.</span><span class="n">from_detector_error_model</span><span class="p">(</span><span class="n">detector_error_model</span><span class="p">)</span>

    <span class="c1"># Run the decoder.</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">decode_batch</span><span class="p">(</span><span class="n">detection_events</span><span class="p">)</span>

    <span class="c1"># Count the mistakes.</span>
    <span class="n">num_errors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">shot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_shots</span><span class="p">):</span>
        <span class="n">actual_for_shot</span> <span class="o">=</span> <span class="n">observable_flips</span><span class="p">[</span><span class="n">shot</span><span class="p">]</span>
        <span class="n">predicted_for_shot</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[</span><span class="n">shot</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">actual_for_shot</span><span class="p">,</span> <span class="n">predicted_for_shot</span><span class="p">):</span>
            <span class="n">num_errors</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">num_errors</span>
</pre></div>
</div>
</div>
</div>
<p>The function returns the number of logical errors for <code class="docutils literal notranslate"><span class="pre">num_shots</span></code>. From that, we can compute the <strong>logical error rate (LER)</strong> per shot needed for our threshold evaluation.</p>
<p>Next, let’s run our threshold estimation for our repetition code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">num_shots</span> <span class="o">=</span> <span class="mi">10_000</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- Code distance:&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">noise</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]:</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
            <span class="s2">&quot;repetition_code:memory&quot;</span><span class="p">,</span>
            <span class="n">rounds</span><span class="o">=</span><span class="n">d</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
            <span class="n">distance</span><span class="o">=</span><span class="n">d</span><span class="p">,</span>
            <span class="n">before_round_data_depolarization</span><span class="o">=</span><span class="n">noise</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">num_errors_sampled</span> <span class="o">=</span> <span class="n">count_logical_errors</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">num_shots</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decoding errors at noise level </span><span class="si">{</span><span class="n">noise</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">num_errors_sampled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
        <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_errors_sampled</span> <span class="o">/</span> <span class="n">num_shots</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;d=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;physical error rate&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;logical error rate per shot&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The results look very promising. Based on our simulation, the threshold for the repetition code is around <span class="math notranslate nohighlight">\(p=0.4\)</span>!</p>
<p>For physical noise levels <span class="math notranslate nohighlight">\(\le p\)</span> we observe a significant decrease of the LER, consistent with the threshold theorem.</p>
<p>Unfortunately, the repetition code is not as good as the graph might indicate!</p>
<p>There are several problems with our result:</p>
<ul class="simple">
<li><p>The repetition code doesn’t consider <span class="math notranslate nohighlight">\(Z\)</span>-type errors</p></li>
<li><p>We didn’t introduce any reset or measurement errors</p></li>
<li><p>Our noise model is missing important error processes such as for example <em>leakage</em>, where the qubit escapes its computational subspace and leaks to higher energy states such as <span class="math notranslate nohighlight">\(\ket{2}, \ket{3}, ...\)</span>.</p></li>
</ul>
<p>Nevertheless, we were able to estimate the code threshold with a few lines of code, demonstrating the usefulness of Stim :-)</p>
<p>Next, we are going to evaluate the Surface Code under a slightly more realistic noise model to get an idea of the threshold value of a <em>real</em> quantum code.</p>
</section>
<section id="exercise-estimating-the-threshold-of-the-surface-code">
<h2>Exercise: Estimating the Threshold of the Surface Code<a class="headerlink" href="#exercise-estimating-the-threshold-of-the-surface-code" title="Link to this heading">#</a></h2>
<p><strong>Exercise 2:</strong> Re-use the code for the repetition code to evaluate the Surface Code threshold. This time introduce reset and measurement errors as well depolarizing errors before the QEC cycles.</p>
<p><strong>Tip 1:</strong> The threshold for the Surface Code is significantly lower than the one for the repetition code. Use a noise range between <span class="math notranslate nohighlight">\([0.002, 0.009]\)</span> to find the threshold.</p>
<p><strong>Tip 2:</strong> Observe the number of shots needed to sample a logical error and adjust the number of shots accordingly</p>
<p><strong>Exercise 3:</strong> The error suppression factor <span class="math notranslate nohighlight">\(\Lambda = \frac{\varepsilon_d}{\varepsilon_{d+2}}\)</span> is an important metric to see if our code effectively suppresses the error.</p>
<p>The LER is denoted as <span class="math notranslate nohighlight">\(\varepsilon_d\)</span>, at a fixed code distance <span class="math notranslate nohighlight">\(d\)</span> and physical error rate <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>Calculate <span class="math notranslate nohighlight">\(\Lambda\)</span> at <span class="math notranslate nohighlight">\(p=2 \times 10^{-3}\)</span> and compare it to the theoretical estimate <span class="math notranslate nohighlight">\(p_{thr}/p\)</span>.</p>
<p><strong>Tip:</strong> You can use the <code class="docutils literal notranslate"><span class="pre">results</span></code> list object for your calculations.</p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h3>
<p>To learn more about Stim:</p>
<ul class="simple">
<li><p>Read the <a class="reference external" href="https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"><code class="docutils literal notranslate"><span class="pre">Getting</span> <span class="pre">Started</span> <span class="pre">Tutorial</span></code></a> which forms the basis for this notebook.</p></li>
<li><p>Check out the paper <a class="reference external" href="https://quantum-journal.org/papers/q-2021-07-06-497/"><code class="docutils literal notranslate"><span class="pre">Stim:</span> <span class="pre">A</span> <span class="pre">fast</span> <span class="pre">stabilizer</span> <span class="pre">circuit</span> <span class="pre">simulator</span></code></a> to learn about Stim’s internals and how it is leveraging <a class="reference external" href="https://www.intel.com/content/www/us/en/support/articles/000005779/processors.html">SIMD instructions</a> to squeeze the maximum performance out of our CPUs.</p></li>
</ul>
<p>To learn more about the Surface Code:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1208.0928">Paper</a> introducing the surface code and logical gates by Fowler et al.</p></li>
<li><p>Google’s Surface Code experiment: <a class="reference external" href="https://arxiv.org/html/2408.13687v1#S11"><code class="docutils literal notranslate"><span class="pre">Quantum</span> <span class="pre">error</span> <span class="pre">correction</span> <span class="pre">below</span> <span class="pre">the</span> <span class="pre">surface</span> <span class="pre">code</span> <span class="pre">threshold</span></code></a> contains a lot of details about different noise simulation techniques and other decoder types.</p></li>
</ul>
<p>To learn more about QEC codes, visit the QEC Zoo: https://errorcorrectionzoo.org/ !</p>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="qaoa_exercise.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Tutorial - Variational Quantum Algorithms</p>
      </div>
    </a>
    <a class="right-next"
       href="../slides/index.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Slides</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#python-dependencies">Python Dependencies</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-surface-code">The Surface Code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#surface-code-circuit-in-stim">Surface Code Circuit in Stim</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#circuit-metadata">Circuit Metadata</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#detectors">Detectors</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#final-measurement-round">Final Measurement Round</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#detectors-in-the-absence-of-noise">Detectors in the Absence of Noise</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#noisy-surface-code-circuits">Noisy Surface Code Circuits</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-detector-error-model-dem">The Detector Error Model (DEM)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-dem-for-repetition-code">Example: DEM for Repetition Code</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dem-model-and-the-tanner-graph">DEM model and the Tanner Graph</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dem-model-for-decoder-research-and-reproducibility">DEM model for Decoder Research and Reproducibility</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#decoding-errors-minimum-weight-perfect-matching">Decoding Errors: Minimum-Weight Perfect Matching</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#estimating-the-repetition-code-threshold">Estimating the Repetition Code Threshold</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-estimating-the-threshold-of-the-surface-code">Exercise: Estimating the Threshold of the Surface Code</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By NordIQuEst
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, NordIQuEst.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  
    <div style="width: 100%; text-align: center; padding: 10px 0;">
        <a href="https://nordiquest.net" target="_blank">https://nordiquest.net</a>
        <hr>
        <p><strong>Funding</strong></p>
        <p>NordIQuEst is a project of the <a href="https://neic.no" target="_blank"><b>Nordic e-Infrastructure Collaboration (NeIC).</b></a>. NeIC is an organisational unit under <a href="https://www.nordforsk.org/" target="_blank"><b>NordForsk.</b></a>.</p>
        <p>Project Manager: Alberto Lanzanova (alberto.lanzanova at csc.fi)</p>
    </div>

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>